<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Auto-Indentation Feature in IDLE</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css"/>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.3.1/reveal.min.css"/>
    <style>
        body {
            font-family: 'Montserrat', sans-serif;
            background-color: #f4f4f4;
            color: #333;
        }
        h1, h2, h3 {
            text-align: center;
        }
        .container {
            width: 80%;
            margin: auto;
            overflow: hidden;
        }
        .section {
            margin: 20px 0;
            padding: 20px;
            background: #fff;
            border-radius: 8px;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
        }
        pre {
            background: #272822;
            color: #f8f8f2;
            padding: 15px;
            border-radius: 8px;
            overflow-x: auto;
        }
        .code {
            font-family: 'Source Code Pro', monospace;
            font-size: 14px;
        }
        #diagram {
            display: block;
            margin: auto;
            background: #f4f4f4;
        }
    </style>
</head>
<body>
    <div class="reveal">
        <div class="slides">
            <section>
                <h1 class="animate__animated animate__fadeIn">Auto-Indentation Feature in IDLE</h1>
            </section>
            <section>
                <div class="section animate__animated animate__fadeInUp">
                    <h2>Introduction</h2>
                    <p>The Auto-Indentation feature in IDLE helps maintain consistent code formatting by automatically adjusting the indentation of new lines based on the context of the previous lines. This feature is particularly useful for Python programming, where indentation plays a crucial role in defining code blocks.</p>
                </div>
            </section>
            <section>
                <div class="section animate__animated animate__fadeInUp">
                    <h2>Key Function: <code>newline_and_indent_event</code></h2>
                    <p>The main function responsible for auto-indentation in IDLE is <code>newline_and_indent_event</code>. This function is triggered when the Enter key is pressed, and it ensures that the new line is indented appropriately.</p>
                </div>
            </section>
            <section>
                <div class="section animate__animated animate__fadeInUp">
                    <h2>Implementation Details</h2>
                    <pre class="code">
def newline_and_indent_event(self, event):
    """Insert a newline and indentation after Enter keypress event.

    Properly position the cursor on the new line based on information
    from the current line. This takes into account if the current line
    is a shell prompt, is empty, has selected text, contains a block
    opener, contains a block closer, is a continuation line, or
    is inside a string.
    """
    text = self.text
    first, last = self.get_selection_indices()
    text.undo_block_start()
    try:  # Close undo block and expose new line in finally clause.
        if first and last:
            text.delete(first, last)
            text.mark_set("insert", first)
        line = text.get("insert linestart", "insert")

        # Count leading whitespace for indent size.
        i, n = 0, len(line)
        while i < n and line[i] in " \t":
            i += 1
        if i == n:
            # The cursor is in or at leading indentation in a continuation
            # line; just inject an empty line at the start.
            text.insert("insert linestart", '\n',
                        self.user_input_insert_tags)
            return "break"
        indent = line[:i]

        # Strip whitespace before insert point unless it's in the prompt.
        i = 0
        while line and line[-1] in " \t":
            line = line[:-1]
            i += 1
        if i:
            text.delete("insert - %d chars" % i, "insert")

        # Strip whitespace after insert point.
        while text.get("insert") in " \t":
            text.delete("insert")

        # Insert new line.
        text.insert("insert", '\n', self.user_input_insert_tags)

        # Adjust indentation for continuations and block open/close.
        # First need to find the last statement.
        lno = index2line(text.index('insert'))
        y = pyparse.Parser(self.indentwidth, self.tabwidth)
        if not self.prompt_last_line:
            for context in self.num_context_lines:
                startat = max(lno - context, 1)
                startatindex = repr(startat) + ".0"
                rawtext = text.get(startatindex, "insert")
                y.set_code(rawtext)
                bod = y.find_good_parse_start(
                        self._build_char_in_string_func(startatindex))
                if bod is not None or startat == 1:
                    break
            y.set_lo(bod or 0)
        else:
            r = text.tag_prevrange("console", "insert")
            if r:
                startatindex = r[1]
            else:
                startatindex = "1.0"
            rawtext = text.get(startatindex, "insert")
            y.set_code(rawtext)
            y.set_lo(0)

        c = y.get_continuation_type()
        if c != pyparse.C_NONE:
            # The current statement hasn't ended yet.
            if c == pyparse.C_STRING_FIRST_LINE:
                # After the first line of a string do not indent at all.
                pass
            elif c == pyparse.C_STRING_NEXT_LINES:
                # Inside a string which started before this line;
                # just mimic the current indent.
                text.insert("insert", indent, self.user_input_insert_tags)
            elif c == pyparse.C_BRACKET:
                # Line up with the first (if any) element of the
                # last open bracket structure; else indent one
                # level beyond the indent of the line with the
                # last open bracket.
                self.reindent_to(y.compute_bracket_indent())
            elif c == pyparse.C_BACKSLASH:
                # If more than one line in this statement already, just
                # mimic the current indent; else if initial line
                # has a start on an assignment stmt, indent to
                # beyond leftmost =; else to beyond first chunk of
                # non-whitespace on initial line.
                if y.get_num_lines_in_stmt() > 1:
                    text.insert("insert", indent,
                                self.user_input_insert_tags)
                else:
                    self.reindent_to(y.compute_backslash_indent())
            else:
                assert 0, "bogus continuation type %r" % (c,)
            return "break"

        # This line starts a brand new statement; indent relative to
        # indentation of initial line of closest preceding
        # interesting statement.
        indent = y.get_base_indent_string()
        text.insert("insert", indent, self.user_input_insert_tags)
        if y.is_block_opener():
            self.smart_indent_event(event)
        elif indent and y.is_block_closer():
            self.smart_backspace_event(event)
        return "break"
    finally:
        text.see("insert")
        text.undo_block_stop()
                    </pre>
                </div>
            </section>
            <section>
                <div class="section animate__animated animate__fadeInUp">
                    <h2>Function Breakdown</h2>
                    <p>The <code>newline_and_indent_event</code> function performs several key tasks:</p>
                    <ul>
                        <li>Deletes any selected text.</li>
                        <li>Counts leading whitespace to determine the indentation level.</li>
                        <li>Strips whitespace around the cursor position.</li>
                        <li>Inserts a new line and adjusts indentation based on the context of the current line.</li>
                        <li>Handles various cases such as block openers, block closers, continuation lines, and string literals.</li>
                    </ul>
                </div>
            </section>
            <section>
                <div class="section animate__animated animate__fadeInUp">
                    <h2>Diagram</h2>
                    <svg id="diagram" width="700" height="200"></svg>
                </div>
            </section>
            <section>
                <div class="section animate__animated animate__fadeInUp">
                    <h2>Conclusion</h2>
                    <p>The Auto-Indentation feature in IDLE streamlines the coding process by automatically managing indentation levels, ensuring consistent and readable code. This feature is an essential part of the IDLE editor, helping developers maintain proper code structure effortlessly.</p>
                </div>
            </section>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/reveal.js/4.3.1/reveal.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.1.1/d3.min.js"></script>
    <script>
        Reveal.initialize({
            transition: 'slide', // none/fade/slide/convex/concave/zoom
            fragments: true
        });

        // Create a diagram using D3.js
        const svg = d3.select("#diagram");
        const width = +svg.attr("width");
        const height = +svg.attr("height");

        const stages = [
            {text: "User types new line", x: 50, y: 50},
            {text: "Analyze previous line's indentation", x: 300, y: 50},
            {text: "Auto-indent new line", x: 550, y: 50}
        ];

        svg.selectAll("circle")
            .data(stages)
            .enter()
            .append("circle")
            .attr("cx", d => d.x)
            .attr("cy", d => d.y)
            .attr("r", 20)
            .attr("fill", "#3498db")
            .transition()
            .duration(1000)
            .delay((d, i) => i * 500)
            .attr("r", 40);

        svg.selectAll("text")
            .data(stages)
            .enter()
            .append("text")
            .attr("x", d => d.x)
            .attr("y", d => d.y)
            .attr("dy", ".35em")
            .attr("text-anchor", "middle")
            .attr("fill", "#ffffff")
            .text(d => d.text)
            .style("opacity", 0)
            .transition()
            .duration(1000)
            .delay((d, i) => i * 500)
            .style("opacity", 1);
    </script>
</body>
</html>

